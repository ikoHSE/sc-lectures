---
theme: superblack
author: Ilya Kostyuchenko
---

# –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ

---

## –ù–∞–ø–æ–º–∏–Ω–∞–ª–æ—á–∫–∞

```{ .haskell }
class Functor f where
  fmap :: (a -> b) -> f a -> f b
```

```{ .haskell .fragment }
class Functor f => Applicative f where
  (<*>) :: f (a -> b) -> f a -> f b
  pure :: a -> f a
```

```{ .haskell .fragment }
class Applicative f => Monad f where
  (>>=) :: f a -> (a -> f b) -> f b
  return :: a -> f a
```

---

## Either

```{ .haskell }
data Either a b = Left a | Right b
```

```{ .haskell .fragment }
throwError :: e -> Either e a
throwError = Left
```

```{ .haskell .fragment }
data PaymentError = InsufficientBalance

pay :: Balance -> Price -> Either PaymentError Balance
pay balance price = do
  let newBalance = balance - price
  when (newBalance < 0) (throwError InsufficientBalance)
  return newBalance
```

```{ .haskell .fragment }
when :: (Applicative f) => Bool -> f () -> f ()
when p s  = if p then s else pure ()
```

---

# State

```{ .haskell }
data State s a = State { runState :: s -> (a, s) }
```

```{ .haskell .fragment }
get :: State s s
get = State (\s -> (s, s))

put :: s -> State s ()
put s = State (\_ -> (_, s))
```

---

```{ .haskell }
getNewId :: State TransactionId TransactionId
getNewId = do
  newId <- get
  put (succ newId)
  return newId

data Transaction = Transaction
  { transactionId :: TransactionId,
    transactionAmount :: Price
  }
```

```{ .haskell .fragment }
registerPayment :: Price -> State TransactionId Transaction
registerPayment price = do
  newId <- getNewId
  return Transaction
    { transactionId = newId
      transactionAmount = price
    }
```

---

```{ .haskell }
registerPayment :: Price -> State TransactionId Transaction
pay :: Balance -> Price -> Either PaymentError Balance
```

```{ .haskell .fragment }
payAndRegister balance price = do
  newBalance <- pay balance price
  transacation <- registerPayment price
  return (newBalance, transaction)
```

```{ .haskell .fragment }
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
```

```{ .haskell .fragment }
-- –¢–∞–∫–æ–≥–æ –Ω–µ—Ç
(>=>)
  :: (Monad m, Monad n)
  => (a -> m b) -> (b -> n c) -> (a -> ? c)
```

[–ù–∞ –∫–∞–∂–¥—ã–π —á–∏—Ö –Ω—É–∂–Ω–æ —Å–æ–∑–¥–∞–≤–∞—Ç—å –Ω–æ–≤—ã–π —Ç–∏–ø?]{.fragment}

---

–ú—ã —Ö–æ—Ç–∏–º:

1. –û—Ç–¥–µ–ª–∏—Ç—å —ç—Ñ—Ñ–µ–∫—Ç—ã –æ—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –º–æ–Ω–∞–¥—ã
2. –ü–æ–ª—É—á–∏—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞—Ç—å —Ä–∞–∑–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã

[(–ò —á—Ç–æ–±—ã –Ω–µ –Ω–∞–¥–æ –±—ã–ª–æ –Ω–∞ –∫–∞–∂–¥—ã–π —Å–ª—É—á–∞–π –Ω–æ–≤—ã–π —Ç–∏–ø —Å–æ–∑–¥–∞–≤–∞—Ç—å)]{.fragment}

---

```{ .haskell }
registerPayment :: Price -> State TransactionId Transaction
pay :: Balance -> Price -> Either PaymentError Balance
```

```{ .haskell .fragment }
registerPayment
  :: MonadState TransactionId m
  => Price -> m Transaction
pay
  :: MonadError PaymentError m
  => Balance -> Price -> m Balance
```

```{ .haskell .fragment }
payAndRegister
  :: (MonadState TransactionId m, MonadError PaymentError m)
  => Balance -> Price -> m (Balance, Transaction)
```

---

–ù–∞ —Å–∞–º–æ–º –¥–µ–ª–µ –º—ã —Ö–æ—Ç–∏–º —á—Ç–æ–±—ã –ø–æ–Ω—è—Ç–∏–µ "state" –Ω–µ –±—ã–ª–æ –ø—Ä–∏–≤—è–∑–∞–Ω–æ –∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –º–æ–Ω–∞–¥–µ.

[–ú—ã —Ö–æ—Ç–∏–º —á—Ç–æ–±—ã "–±–∞–∑–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏" –Ω–µ –±—ã–ª–∏ –ø—Ä–∏–≤—è–∑–∞–Ω—ã –∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –º–æ–Ω–∞–¥–µ.]{.fragment}

```{ .haskell .fragment }
-- –ë—ã–ª–æ
get :: State s s
put :: s -> State s ()
```

```{ .haskell .fragment }
-- –°—Ç–∞–ª–æ
get :: MonadState s m => m s
put :: MonadState s m => s -> m ()
```

---

## MonadState

---

<!--
```{ .haskell .fragment }
class MonadState s m | m -> s where
  get :: m s
  put :: s -> m ()
```

[`m -> s` –æ–∑–Ω–∞—á–∞–µ—Ç —á—Ç–æ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ `m` –º–æ–∂–µ—Ç –±—ã—Ç—å —Å—Ç—Ä–æ–≥–æ –æ–¥–∏–Ω `s`.]{ .fragment }

[(–≠—Ç–æ –Ω—É–∂–Ω–æ —á—Ç–æ–±—ã –∫–æ–≥–¥–∞ –≤—ã –¥–µ–ª–∞–µ—Ç–µ `get` –±—ã–ª–æ –ø–æ–Ω—è—Ç–Ω–æ —á—Ç–æ –≤–∞–º –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å.)]{ .fragment } -->
```{ .haskell }
class Monad m => MonadState s m where
  get :: m s
  put :: s -> m ()
```

```{ .haskell .fragment }
data State s a = State { runState :: s -> (a, s) }

instance MonadState s (State s) where
  get = State (\s -> (s, s))
  put s = State (\_ -> ((), s))
```

```{ .haskell .fragment }
getNewId :: MonadState TransactionId m => m TransactionId
getNewId = do
  newId <- get
  put (succ newId)
  return newId
```

```{ .haskell .fragment }
registerPayment :: Price -> State TransactionId Transaction
registerPayment price = do
  newId <- getNewId
  return Transaction
    { transactionId = newId
      transactionAmount = price
    }
```

---

## MonadError

```{ .haskell .fragment }
class Monad m => MonadError e m where
  throwError :: e -> m a
  catchError :: m a -> (e -> m a) -> m a
```

```{ .haskell .fragment }
data Either e a = Left e | Right a

instance MonadError e (Either e) where
  throwError e = Left e

  catchError (Left e) f = f e
  catchError (Right a) _ = Right a
```

---

–ú—ã —Ö–æ—Ç–∏–º:

1. ~~–û—Ç–¥–µ–ª–∏—Ç—å —ç—Ñ—Ñ–µ–∫—Ç—ã –æ—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –º–æ–Ω–∞–¥—ã~~
2. –ü–æ–ª—É—á–∏—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞—Ç—å —Ä–∞–∑–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã

---

–ù–∞—á–Ω–µ–º —Å —Ñ—É–Ω–∫—Ç–æ—Ä–æ–≤

```{ .haskell .fragment }
data Compose f g a = Compose { getCompose :: f (g a) }
```

```{ .haskell .fragment }
type ErrorStateFunctor a =
  Compose (Either PaymentError) (State TransactionId) a
```

```{ .haskell .fragment }
-- Compose
--   { getCompose ::
--       Either PaymentError (State TransactionId a)
--   }
```

```{ .haskell .fragment }
instance (Functor f, Functor g) =>Functor (Compose f g) where
  fmap f (Compose x) = Compose (fmap (fmap f) x)
```

[üéâ]{ .fragment }

[(`Applicative` —Ç–æ–∂–µ –º–æ–∂–Ω–æ -- –º–æ–∂–µ—Ç–µ —Å–∞–º–∏ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å)]{ .fragment }

---

–ö –º–æ–Ω–∞–¥–∞–º!

```{ .haskell .fragment }
instance (Monad f, Monad g) => Monad (Compose f g) where
  return x = Compose (return (return x))
  (Compose x) >>= f = ???
```

[üò¢]{ .fragment }

[–í—Å–µ —Ä–∞–≤–Ω–æ —Ö–æ—á–µ—Ç—Å—è!]{ .fragment }

---


```{ .haskell }
data Compose f g a = Compose { getCompose :: f (g a) }
```

[–î–ª—è —Ç–∞–∫–æ–≥–æ –Ω–µ –º–æ–∂–µ–º]{ .fragment }


```{ .haskell .fragment }
data ErrorState e s a =
  ErrorState { runErrorState :: State s (Either e a) }
```

[–ê –¥–ª—è —Ç–∞–∫–æ–≥–æ –º–æ–∂–µ–º!]{ .fragment }

```{ .haskell .fragment }
(State s (Either e a)) ~ (s -> Either e (a, s))
```

---

```{ .haskell }
data ErrorState e s a =
  ErrorState { runErrorState :: State s (Either e a) }
```

[–•–æ—á–µ—Ç—Å—è —á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ –Ω–µ —Ç–æ–ª—å–∫–æ `Either`!]{ .fragment }

```{ .haskell .fragment }
data State  s   a = State  { runState  :: s ->   (a, s) }
```

```{ .haskell .fragment }
data StateT s m a = StateT { runStateT :: s -> m (a, s) }
```

```{ .haskell .fragment }
instance (Monad m) => Monad (StateT s m) where
  return a = StateT $ \ s -> return (a, s)

  m >>= f = StateT (\s -> do
    (a, s') <- runStateT m s
    runStateT (f a) s'
    )
```


---

## Transformers!

![](images/transformer.gif){height=400px}

---

## –í–µ—Ä–Ω–µ–º –æ–ø–µ—Ä–∞—Ü–∏–∏!

```{ .haskell }
class Monad m => MonadState s m where
  get :: m s
  put :: s -> m ()
```

```{ .haskell .fragment }
data StateT s n a = StateT { runStateT :: s -> n (a, s) }
```

```{ .haskell .fragment }
instance Monad n => MonadState s (StateT s n) where
  get = StateT (\s -> return (s, s))
  put s = StateT (\_ -> return ((), s)
```

---

## Error

```{ .haskell .fragment }
data ExceptT e n a = ExceptT { runExceptT :: n (Either e a) }
```

```{ .haskell .fragment }
class Monad m => MonadError e m where
  throwError :: e -> m a
  catchError :: m a -> (e -> m a) -> m a
```

```{ .haskell .fragment }
instance Monad n => MonadError e (ExceptT e n) where
  throwError e = ExceptT (return (Left e))

  catchError (ExceptT n) f = ExceptT $ do
    x <- n
    case x of
      Left e -> runExceptT (f e)
      Right a -> return (Right a)
```

---

```{ .haskell }
class Monad m => MonadError e m where
  throwError :: e -> m a
  catchError :: m a -> (e -> m a) -> m a
```

```{ .haskell .fragment }
data PaymentError = InsufficientBalance

pay :: MonadError e m => Balance -> Price -> m Balance
pay balance price = do
  let newBalance = balance - price
  when (newBalance < 0) (throwError InsufficientBalance)
  return newBalance
```

---

## The states


```{ .haskell .fragment }
data State  s   a = State  { runState  :: s ->   (a, s) }
```

```{ .haskell .fragment }
data StateT s m a = StateT { runStateT :: s -> m (a, s) }
```

[ü§î]{.fragment}

---

–ù–∞–ø–æ–º–∏–Ω–∞–ª–æ—á–∫–∞:

```{ .haskell .fragment }
data Identity a = Identity { runIdentity :: a }
```

```{ .haskell .fragment }
(Identity a) ~ a
```

```{ .haskell .fragment }
data State  s   a = State  { runState  :: s ->   (a, s) }

data StateT s m a = StateT { runStateT :: s -> m (a, s) }
```

```{ .haskell .fragment }
(StateT s Identity a) ~ (s -> Identity (a, s))
```

[ü§î]{.fragment}

```{ .haskell .fragment }
(s -> Identity (a, s)) ~ (s -> (a, s)) ~ (State s a)
```

```{ .haskell .fragment }
type State s a = StateT s Identity a
```

---

```{ .haskell }
data ExceptT e n a = ExceptT { runExceptT :: n (Either e a) }

data StateT s m a = StateT { runStateT :: s -> m (a, s) }

class Monad m => MonadError e m where
  throwError :: e -> m a
  catchError :: m a -> (e -> m a) -> m a

class Monad m => MonadState s m where
  get :: m s
  put :: s -> m ()
```

–ü—Ä–∏—à–ª–∏ –∫ —Ç–æ–º—É, —Å —á–µ–≥–æ –Ω–∞—á–∏–Ω–∞–ª–∏, —Ç–æ–ª—å–∫–æ –µ—â–µ —Å–ª–æ–∂–Ω–µ–µ

---

1. ~~–û—Ç–¥–µ–ª–∏—Ç—å —ç—Ñ—Ñ–µ–∫—Ç—ã –æ—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –º–æ–Ω–∞–¥—ã~~
2. –ü–æ–ª—É—á–∏—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞—Ç—å —Ä–∞–∑–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã

---

```{ .haskell }
foo :: ExceptT Bool (State Char) Int
foo = do
  c <- get -- :: State Char Char
  throwError True -- :: ExceptT Bool (State Char) Int
```

```{ .haskell .fragment }
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)

-- –¢–∞–∫–æ–≥–æ –Ω–µ—Ç
(>=>)
  :: (Monad m, Monad n)
  => (a -> m b) -> (b -> n c) -> (a -> ? c)
```

```{ .haskell .fragment }
lift :: State Char a -> ExceptT Bool (State Char) a
```

```{ .haskell .fragment }
foo :: ExceptT Bool (State Char) Int
foo = do
  c <- lift get -- :: ExceptT Bool (State Char) Int
  throwError True -- :: ExceptT Bool (State Char) Int
```

---

```{ .haskell }
class MonadTrans t where
    lift :: (Monad m) => m a -> t m a
```

```{ .haskell .fragment }
lift :: State Char a -> ExceptT Bool (State Char) a
--      (m       ) a -> (t         ) (m         ) a
```

```{ .haskell .fragment }
instance MonadTrans (StateT s) where
  lift m = StateT $ \ s -> do
    a <- m
    return (a, s)
```

```{ .haskell .fragment }
instance MonadTrans (ExceptT e) where
  lift m = ExceptT (fmap Right m)
```

```{ .haskell .fragment }
foo :: ExceptT Bool (State Char) Int
foo = do
  c <- lift get
  throwError True
```

---

–ù–æ —Ö–æ—á–µ—Ç—Å—è —á—Ç–æ–±—ã –±–µ–∑ `lift` üôÇ

```{ .haskell .fragment }
foo :: ExceptT Bool (State Char) Int
foo = do
  c <- get
  throwError True
```

[–ù—É–∂–µ–Ω –∏–Ω—Å—Ç–∞–Ω—Å `MonadState` –¥–ª—è `ExceptT`]{ .fragment }

```{ .haskell .fragment }
instance MonadState s n => MonadState s (ExceptT e n) where
    get = lift get
    put s = lift (put s)
```

---


```{ .haskell }
registerPayment
  :: State TransactionId m
  => Price -> m Transaction
pay
  :: MonadError PaymentError m
  => Balance -> Price -> m Balance
```

```{ .haskell .fragment }
payAndRegister
  :: (State TransactionId m, MonadError PaymentError m)
  => Balance -> Price -> m (Balance, Transaction)
payAndRegister balance price = do
  newBalance <- pay balance price
  transacation <- registerPayment price
  return (newBalance, transaction)
```

---

–ö–∞–∫ —ç—Ç–æ "–∑–∞–ø—É—Å–∫–∞—Ç—å"?

```{ .haskell }
payAndRegister
  :: (State TransactionId m, MonadError PaymentError m)
  => Balance -> Price -> m (Balance, Transaction)
```

```{ .haskell .fragment }
myBalance :: Balance
myPrice :: Price

balanceAndTransaction
  :: Either PaymentError (Balance, Transaction)
```

```{ .haskell .fragment }
data ExceptT e n a = ExceptT { runExceptT :: n (Either e a) }
data StateT s n a = StateT { runStateT :: s -> n (a, s) }
```


```{ .haskell .fragment }
balanceAndTransaction =
  runStateT 0 (payAndRegister myBalance myPrice)
```

---

```{ .haskell }
payAndRegister
  :: (State TransactionId m, MonadError PaymentError m)
  => Balance -> Price -> m (Balance, Transaction)

data StateT s n a = StateT { runStateT :: s -> n (a, s) }
```

```{ .haskell .fragment }
balanceAndTransaction
  :: Either PaymentError (Balance, Transaction)
balanceAndTransaction =
  flip runStateT 0 (payAndRegister myBalance myPrice)
```

```{ .haskell .fragment }
  flip runStateT 0 (payAndRegister myBalance myPrice)
-- ^-------------^
-- StateT TransactionId n a -> n a
```

```{ .haskell .fragment }
-- (n a) ~ (Either PaymentError (Balance, Transaction))
```

```{ .haskell .fragment }
flip runStateT 0 (payAndRegister myBalance myPrice)
--               ^--------------------------------^
--                    StateT TransactionId
--                      (Either PaymentError)
--                      (Balance, Transaction)
```

---

```{ .haskell }
payAndRegister
  :: (State TransactionId m, MonadError PaymentError m)
  => Balance -> Price -> m (Balance, Transaction)

data ExceptT e n a = ExceptT { runExceptT :: n (Either e a) }
data StateT s n a = StateT { runStateT :: s -> n (a, s) }
data Identity a = Identity { runIdentity :: a }
```

```{ .haskell .fragment }
balanceAndTransaction
  :: Either PaymentError (Balance, Transaction)
balanceAndTransaction =
  (runIdentity . runExceptT . flip runStateT 0)
    (payAndRegister myBalance myPrice)
```

---

–ê —Ç–µ–ø–µ—Ä—å –º—ã –ø–æ–π–¥–µ–º –≤ —Å–æ–≤–µ—Ä—à–µ–Ω–Ω–æ –¥—Ä—É–≥–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏!

---

## –ù–∞–ø–æ–º–∏–Ω–∞–ª–æ—á–∫–∞

```{ .haskell .fragment }
class Show a where
  show :: a -> String
```

```{ .haskell .fragment }
data Foo = Bar { barInt :: Int }
  deriving Show
```

```{ .haskell .fragment }
show (Bar 8)
-- Bar {barInt = 8}
```

---

## Read

–û–±—Ä–∞—Ç–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è –∫ `show`

```{ .haskell }
read :: Read a => String -> a
```

```{ .haskell .fragment }
class Read a where
  readsPrec
    :: -- | –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –≤—ã—Ä–∞–∂–µ–Ω–∏—è
       Int
    -> String
    -> [(a, String)]
```

```{ .haskell .fragment }
data Foo = Bar { barInt :: Int }
  deriving (Show, Read)
```

```{ .haskell .fragment }
read "Bar {barInt = 8}"
-- Bar { barInt = 8 }
```

---

# –ú–æ–Ω–∞–¥—ã

1. –ë–∞–∑–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –º–æ–Ω–∞–¥—ã (—ç—Ñ—Ñ–µ–∫—Ç—ã)

[`MonadState`, `MonadErrror`]{ .fragment }

2. –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –º–æ–Ω–∞–¥—ã (–ø–µ—Ä–µ–Ω–æ—Å—á–∏–∫) (–∏ —Å–ø–æ—Å–æ–±—ã –∏—Ö "—Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞—Ç—å")

[`StateT` (`runStateT`), `Either`, `ExceptT` (`runExceptT`)]{ .fragment }

[–ü–µ—Ä–µ–≤–æ–¥—è—Ç —ç—Ñ—Ñ–µ–∫—Ç—ã –≤ pure –∫–æ–¥]{ .fragment }

---

# –ú–æ–Ω–∞–¥–∞ `IO`

[–û–±–ª–∞–¥–∞–µ—Ç —Ç–æ–ª—å–∫–æ –±–∞–∑–æ–≤—ã–º–∏ –æ–ø–µ—Ä–∞—Ü–∏—è–º–∏]{ .fragment }
[(–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø–µ—Ä–µ–≤–µ—Å—Ç–∏ –≤ pure –∫–æ–¥)]{ .fragment }

```{ .haskell .fragment }
getLine :: IO String

putStrLn :: String -> IO ()
```

```{ .haskell .fragment }
type FilePath = String

readFile :: FilePath -> IO String

writeFile :: FilePath -> String -> IO ()
```

---

```{ .haskell }
add10FromConsole :: IO ()
add10FromConsole = do
  x <- getLine
  let
    n :: Int
    n = read x
  putStrLn (show (n + 10))
```

---

"–†–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞—Ç—å" `IO` —É–º–µ–µ—Ç —Ç–æ–ª—å–∫–æ —Ä–∞–Ω—Ç–∞–π–º.

```{ .haskell .fragment }
main :: IO ()
main = add10FromConsole
```

```{ .fragment }
> 10
20
```

---

```{ .haskell }
-- –ö–∞–∫ 'read', –Ω–æ –Ω–µ –≤–∑—Ä—ã–≤–∞–µ—Ç—Å—è –≤ —Ä–∞–Ω—Ç–∞–π–º–µ
readMaybe :: Read a => String -> Maybe a
```

```{ .haskell .fragment }
accumulateNums :: StateT Int IO ()
accumulateNums = do
  x <- lift getLine
  case (readMaybe x :: Int) of
    Nothing -> do
      s <- get
      lift (putStrLn (show s))
    Just x' -> do
      modify (+ x')
      accumulateNums
```

```{ .haskell .fragment }
main :: IO ()
main = flip runStateT 0 accumulateNums
```

```{ .fragment }
> 8
> 3
> a
11
```

---

```{ .haskell }
accumulateNums :: StateT Int IO ()
```

```{ .haskell .fragment }
-- –•–æ—á–µ—Ç—Å—è —Ç–∞–∫, –Ω–æ –≥–¥–µ —Ç—É—Ç –≤–∑—è—Ç—å 'IO'?
accumulateNums :: MonadState Int m => m ()
```

[–¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä–∞ `IO` –Ω–µ—Ç.]{ .fragment }

[–¢–æ–≥–¥–∞ `lift`!]{ .fragment }

[–ù–æ `lift` –ø–æ–¥–Ω–∏–º–∞–µ—Ç —Å—Ç—Ä–æ–≥–æ –Ω–∞ –æ–¥–∏–Ω —É—Ä–æ–≤–µ–Ω—å.]{ .fragment }

---

```{ .haskell }
class MonadIO m where
  liftIO :: IO a -> m a
```

```{ .haskell .fragment }
accumulateNums :: (MonadState Int m, MonadIO m) => m ()
accumulateNums = do
  x <- liftIO getLine
  case (readMaybe x :: Int) of
    Nothing -> do
      s <- get
      liftIO (putStrLn (show s))
    Just x' -> do
      modify (+ x')
      accumulateNums
```

```{ .haskell .fragment }
main :: IO ()
main = flip runStateT 0 accumulateNums
```

```{ .fragment }
> 8
> 3
> a
11
```
